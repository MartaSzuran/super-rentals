As we learned earlier, the Ember convention is to place your source code in the app folder. 
For other assets like images and fonts, the convention is to put them in the public folder. 
We will follow this convention by downloading the image file and saving it into 
public/assets/images/teaching-tomster.png.

This time, we would like the page to be served on the /about URL. 
In order to do this, we will need to tell Ember about our plan to add a page at that location. 
Otherwise, Ember will think we have visited an invalid URL!

The place to manage what pages are available is the router.

SO TO ADD NEW PAGE FIRST I NEED TO VISIT ROUTER.JS.
and add code: 

Router.map(function () {
  this.route('about');
});

-------------

creating in templates about.hbs

this.route('contact', {path: 'getting-in-touch'});  <- alias is contact but the path will be 
getting-in-touch


Since Ember offers great support for URLs out-of-the-box, we could just link our pages together 
using the <a> tag with the appropriate href. But in ember they provide us <LinkTo>
syntax: 
<LinkTo @route="about" class="button">About</LinkTo>

<LinkTo>-  is an example of a component
@route  -  is how we pass arguments into the component
Note that this should be the name of the route, not the path, 
which is why we specified "about" instead of "/about"

passed without the @ symbol (class=... as opposed to @class=...), 
so that Ember will know they are just regular HTML attributes.

<LinkTo> avoid full page refresh in opposite to <a> which refresh all page by sending request to the server
------------------------------
TESTES
Adding Acceptance Tests with Generators

$ ember generate acceptance-test super-rentals
installing acceptance-test
  create tests/acceptance/super-rentals-test.js

This is called a generator command in Ember CLI.

follows the pattern ember generate <type> <name>, 
where <type> is the kind of thing we are generating, and <name> is what we want to call it.

we can call also ember g <type> <name>

acceptance test == application test

import { module, test } from 'qunit';
import { click, visit, currentURL } from '@ember/test-helpers';
import { setupApplicationTest } from 'ember-qunit';

module('Acceptance | super rentals', function (hooks) {
  setupApplicationTest(hooks);

  test('visiting /', async function (assert) {
    await visit('/');

    assert.strictEqual(currentURL(), '/');
    assert.dom('h2').hasText('Welcome to Super Rentals!');

    assert.dom('.jumbo a.button').hasText('About Us');
    await click('.jumbo a.button');

    assert.strictEqual(currentURL(), '/about');
  });
});

!!!!test into motion by running the test server using the ember test --server!!!!

test('visiting /' ... - visit is ember test helper - it is like we type go to 
http://localhost:4200/ in the browser's address bar and hitting the enter key

!!!! AWAIT
await keyword. That way, it will wait until the page completely finishes loading before moving on to the next step.
any user interaction, needs to be await-ed.

await visit('/');
This is almost always the behavior we want, so we will almost always use await and visit as a pair.

assert.dom('.jumbo a.button')
"look inside the tag with the jumbo class for an <a> tag with the button class."


assert.strictEqual(currentURL(), '/about');
Finally, we asserted that clicking on the link should bring us to the /about URL.

---------------------------
COMPONENTS

component - way to pack code which is repeating

like:
<div class="jumbo">
  <div class="right tomster"></div>
  <!-- page specific content -->
</div>

then create new file f.e.app/components/jumbo.hbs
and:
<div class="jumbo">
  <div class="right tomster"></div>
  {{yield}}
</div>

then just use in code : 
<Jumbo>  <- with capitalize letter!! 

The jumbo.hbs template corresponds to the <Jumbo> tag,
just like super-awesome.hbs corresponds to <SuperAwesome>.
----------------

Passing Content to Components with {{yield}}

just need to emcapsulate content into Jumbo tags :
<Jumbo>some content</Jumbo>

<Jumbo>
  <h2>About Super Rentals</h2>
  <p>
    The Super Rentals website is a delightful project created to explore Ember.
    By building a property rental site, we can simultaneously imagine traveling
    AND building Ember applications.
  </p>
  <LinkTo @route="contact" class="button">Contact Us!</LinkTo>
</Jumbo>

-----------------------
writing test for components

$ ember generate component-test jumbo
installing component-test
  create tests/integration/components/jumbo-test.js

Here, we used the generator to generate a component test, also known as a rendering test. 

-------------------------
creating navbar

create a <NavBar> component at app/components/nav-bar.hbs

app/components/nav-bar.hbs

<nav class="menu">
  <LinkTo @route="index" class="menu-index">
    <h1>SuperRentals</h1>
  </LinkTo>
  <div class="links">
    <LinkTo @route="about" class="menu-about">
      About
    </LinkTo>
    <LinkTo @route="contact" class="menu-contact">
      Contact
    </LinkTo>
  </div>
</nav>

then add at the beggining of each page:
<NavBar />
<Jumbo>
  <h2>About Super Rentals</h2>
  <p>
    The Super Rentals website is a delightful project created to explore Ember.
    By building a property rental site, we can simultaneously imagine traveling
    AND building Ember applications.
  </p>
  <LinkTo @route="contact" class="button">Contact Us</LinkTo>
</Jumbo>

<NavBar /> is a shorthand for <NavBar></NavBar>.

we need to add some test to acceptence tests, because navigation bar should work throughout all app

-----------------------
Using the Application Template and {{outlet}}s

special template called application.hbs

so I need to create that file into templates :
<div class="container">
  <NavBar />
  <div class="body">
    {{outlet}}
  </div>
</div>

and delete all navbar because I have two at the moment :) 

---------------------------
Generating Components

ember generate component rental

 - then add components/rental.hbs
 - then add test

----------------------------------------------------
Organizing Code with Namespaced Components

ember generate component rental/image

This time, we had a / in the component's name. This resulted in the component being created at app/components/rental/image.hbs, 
Components like these are known as namespaced components. Namespacing allows us to organize our components by folders according to their purpose.
which can be invoked as <Rental::Image>

I have folder in templets rental/image.hbs
---------------------------------------
Forwarding HTML Attributes with ...attributes


in: app/components/rental/image.hbs
add:

<div class="image">
  <img ...attributes>
</div>

then this in app/components/rental.hbs:
  <Rental::Image
    src="https://upload.wikimedia.org/wikipedia/commons/c/cb/Crane_estate_(5).jpg"
    alt="A picture of Grand Old Mansion"
  />

adding tests to tests/integration/components/rental/image-test.js and 
tests/integration/components/rental-test.js

-----------------------------------------------
Interactive Components

Adding Behavior to Components with Classes

add a JavaScript file for our <Rental::Image> component by running the component-class generator:

$ ember generate component-class rental/image


This generated a JavaScript file with the same name as our component's template at app/components/rental/image.js. 
It contains a JavaScript class, inheriting from @glimmer/component.
@glimmer/component, or Glimmer component, is one of the several component classes available to use. 


import Component from '@glimmer/component';

export default class RentalImageComponent extends Component {
  constructor(...args) {
    super(...args);
    this.isLarge = false;
  }
}

more concise:
import Component from '@glimmer/component';

export default class RentalImageComponent extends Component {
  isLarge = false;
}


Here, in the component's constructor, we initialized the instance variable this.isLarge with the value false, 
since this is the default state that we want for our component.

we need to update template in app/components/rental/image.hbs


{{#if this.isLarge}}
  <div class="image large">
    <img ...attributes>
    <small>View Smaller</small>
  </div>
{{else}}
  <div class="image">
    <img ...attributes>
    <small>View Larger</small>
  </div>
{{/if}}

adding managing state with tracked properties

by adding a method into image.js:

import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';
import { action } from '@ember/object';

export default class RentalImageComponent extends Component {
  @ tracked isLarge = false;

  @action toggleSize() {
    this.isLarge = !this.isLarge;
  }
}


First, we added the @tracked decorator to the isLarge instance variable. 
This annotation tells Ember to monitor this variable for updates. 
Whenever this variable's value changes, 
Ember will automatically re-render any templates that depend on its value.

method toggleSize() :

toggleSize() {
    this.isLarge = !this.isLarge;
  }
Next, we added a toggleSize method to our class that switches this.isLarge to the opposite 
of its current state (false becomes true, or true becomes false).

with adding @action - This indicates to Ember that we intend to use this method from our template. 

NEXT wire this up in the template in : app/components/rental/image.hbs

--
<button type="button" class="image" {{on "click" this.toggleSize}}>

First, since we wanted to make our component interactive, we switched the 
containing tag from <div> to <button> (this is important for accessibility reasons). 
By using the correct semantic tag, we will also get focusability and keyboard interaction 
handling "for free".

Next, we used the {{on}} modifier to attach 
this.toggleSize as a click handler on the button.

-------------
adding tests
